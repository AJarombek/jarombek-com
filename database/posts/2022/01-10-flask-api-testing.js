/**
 * Script for the MongoDB Shell.
 * @author Andrew Jarombek
 * @since 12/28/2021
 */

connection = new Mongo();
db = connection.getDB("jarombekcom");

content = [
    {
        "el":"note",
        "attributes":{
            "type":"info"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" This is part of a series of articles on SaintsXCTF Version 2.0. The first article in the series provides an ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"overview of the application",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  You ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"DO NOT",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" need to read prior articles in the series to fully understand this article. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/dec-24-2021-flask-python-api"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"prior article",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", I discussed my Flask API written for ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://saintsxctf.com/"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"SaintsXCTF",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", an application which allows users and their teammates to log running exercises and keep track of their running mileage.  As with any piece of software, this Flask API requires extensive testing to keep it functional and maintainable.  In this article, I discuss the automated testing approach I implemented for the API. ",
                "children":null
            }
        ]
    },
    {
        "el":"subtitle",
        "attributes":{
            "title":"SaintsXCTF Version 2.0 Articles"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"SaintsXCTF Version 2.0 Articles",
                "children":null
            }
        ]
    },
    {
        "el":"ul",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Architectural Overview",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"AWS Infrastructure",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/oct-25-2021-saints-xctf-v2-k8s-infrastructure"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Kubernetes Infrastructure",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/nov-1-2021-saints-xctf-v2-react-web-app"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"React Web Application Overview",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/nov-15-2021-react-typescript"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application React and TypeScript",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/dec-3-2021-redux-react"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application Redux State Configuration",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/aug-11-2021-cypress-typescript"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application Cypress E2E Tests",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jun-30-2021-react-jss"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application JSS Modular Design",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/dec-24-2021-flask-python-api"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Flask Python API",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"strong",
                        "attributes":null,
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Flask API Testing",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/feb-5-2022-function-api"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Function API Using API Gateway & Lambda",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/feb-18-2022-auth-api"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Auth API Using API Gateway & Lambda",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/mar-27-2022-mysql-client-kubernetes"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Database Client on Kubernetes",
                                "children":null
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Configuring Automated Tests"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Configuring Automated Tests",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The tests for my application use the built-in Python ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"unittest",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" library, along with the  ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://coverage.readthedocs.io/en/6.2/"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"coverage",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" library for code coverage.  Code coverage determines which lines of API source code are covered by tests, allowing me to find gaps in testing.  The ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"coverage",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" library shows both textual and HTML reports of code coverage, making it extremely easy to drill down into specific source files and find which lines of code aren't being tested. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In the Flask application source code, I created a custom CLI command which triggers the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"unittest",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests with code coverage enabled.  This way, application tests are triggered from the command line with a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"flask test",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" command.  In Flask code, the CLI command is a Python function ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", located within a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-api/blob/v2.0.1/api/src/commands.py#L20-L46"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"commands.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file.  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is added to the Flask application in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/\nv2.0.1/api/src/app.py#L61"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"app.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file with the following line: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"application.cli.add_command(test)\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" starts code coverage, runs the tests, and generates a code coverage report.  The code is shown below, and is inspired by a function found in the book ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://www.oreilly.com/library/view/flask-web-development/9781491991725/"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Flask Web Development",
                        "children":null
                    }
                ]
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"1",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"cov = None\nif os.environ.get('FLASK_COVERAGE'):\n    cov = coverage.coverage(branch=True, include=['app.py', 'dao/*', 'model/*', 'route/*', 'utils/*'])\n    cov.start()\n\n\n@click.command()\n@with_appcontext\ndef test():\n    \"\"\"\n    Create a Flask command for running unit tests.  Execute with 'flask test' from a command line.\n    \"\"\"\n    if not os.environ.get('FLASK_COVERAGE'):\n        os.environ['FLASK_COVERAGE'] = '1'\n        os.execvp(sys.executable, [sys.executable] + sys.argv)\n\n    # Create a test runner an execute the test suite\n    tests = unittest.TestLoader().discover('tests')\n    runner = unittest.TextTestRunner(verbosity=3)\n    result: unittest.TestResult = runner.run(tests)\n\n    if cov:\n        cov.stop()\n        cov.save()\n        print('Coverage Summary:')\n        cov.report()\n        basedir = os.path.abspath(os.path.dirname(__file__))\n        cov_dir = os.path.join(basedir, 'tmp/coverage')\n        cov.html_report(directory=cov_dir)\n        print('HTML version: file://%s/index.html' % cov_dir)\n        cov.erase()\n\n    exit(len(result.errors))\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" runs all the Python files in the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/\nAJarombek/saints-xctf-api/tree/v2.0.1/api/src/tests"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"test",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory of my application. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Testing Approach"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Testing Approach",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Most of the tests in my application invoke API endpoints and assert they return certain HTTP response bodies and response status codes.  This means that in order for my tests to execute successfully, a running instance of the API is needed.  Instead of using the API running in production, I use a test API that is quickly spun up before tests begin and spun down after tests stop.  All the configuration for this test API and the execution environment for the tests themselves is accomplished using Docker and Docker Compose. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In general, each component of my application backend has a corresponding Docker Compose file.  There is also a Docker Compose file for the API tests.  These Docker Compose files exist in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-api/tree/v2.0.1/infra/docker-compose"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"docker-compose",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory in my repository. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" There are five Docker Compose files in total, each running a single Docker container.  There are four Docker Compose files that together complete my application backend.  They are for my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/\nv2.0.1/infra/docker-compose/docker-compose-db-local.yml"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"database",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-api/blob/v2.0.1/infra/docker-compose/docker-compose-auth-local.yml"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"authentication API",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/infra/docker-compose/docker-compose-fn-local.yml"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" AWS Lambda function API",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", and ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/infra/docker-compose/\ndocker-compose-api-local.yml"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"main Flask API",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  These four Docker Compose configurations need to be started using the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"docker-compose up",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" command before the API tests are run.  Once they are running, the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/infra/docker-compose/\ndocker-compose-test-local.yml"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"API test",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" Docker Compose file can be run.  This Docker Compose file starts a container, runs the API tests on that container, and then stops the container.  Its configuration is shown below. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"YAML"
        },
        "value":"# docker-compose-test-local.yml\n\nversion: '3.7'\nservices:\n  test:\n    build:\n      context: ../../api/src/\n      dockerfile: local.test.dockerfile\n      network: host\n    networks:\n      - local-saints-xctf-api-net\n\nnetworks:\n  local-saints-xctf-api-net:\n    driver: bridge\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" This Docker Compose file runs a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/\nlocal.test.dockerfile"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"local.test.dockerfile",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" Dockerfile, which has the following configuration: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Dockerfile"
        },
        "value":"FROM python:3.8-alpine\n\nRUN apk update \\\n    && apk add --virtual .build-deps gcc python3-dev libc-dev libffi-dev g++ \\\n    && pip install --upgrade pip \\\n    && pip install pipenv\n\nCOPY . /src\nWORKDIR /src\n\nRUN pipenv install\n\nENV FLASK_APP app.py\nENV ENV localtest\n\nCOPY credentials .aws/\nENV AWS_DEFAULT_REGION us-east-1\nENV AWS_SHARED_CREDENTIALS_FILE .aws/credentials\n\nENTRYPOINT [\"pipenv\", \"run\", \"flask\", \"test\"]\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" At its core, this container uses a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"python:3.8-alpine",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" container as its base, installs necessary dependencies for the API code, and runs the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"flask test",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" command in the container ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"ENTRYPOINT",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Running this container shows a console output similar to the following: ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":null,
        "value":"Starting docker-compose_test_1 ... done\nAttaching to docker-compose_test_1\ntest_1  | test_app_exists (test_src.testApp.TestApp) ... ok\ntest_1  | test_non_existent_route (test_src.testApp.TestApp)\ntest_1  | ...\ntest_1  | test_user_update_last_login_by_username_put_route_unauthorized (test_src.test_route.testUserRoute.TestUserRoute)\ntest_1  | Test performing an unauthorized HTTP PUT request on the '/v2/users/<username>/update_last_login' route. ... ok\ntest_1  |\ntest_1  | ----------------------------------------------------------------------\ntest_1  | Ran 467 tests in 77.992s\ntest_1  |\ntest_1  | OK (skipped=11)\ntest_1  | Coverage Summary:\ntest_1  | Name                           Stmts   Miss Branch BrPart  Cover\ntest_1  | ----------------------------------------------------------------\ntest_1  | app.py                            73     35      6      0    48%\ntest_1  | dao/activationCodeDao.py          25      0      0      0   100%\ntest_1  | dao/basicDao.py                   15      0      0      0   100%\ntest_1  | dao/userDao.py                    40      3      0      0    92%\ntest_1  | model/User.py                     75      0      0      0   100%\ntest_1  | model/UserData.py                 30      2      4      2    88%\ntest_1  | route/userRoute.py               486     31    138     30    90%\ntest_1  | utils/exerciseFilters.py          19      2     14      2    88%\ntest_1  | ...\ntest_1  | ----------------------------------------------------------------\ntest_1  | TOTAL                           3625    261    692    154    90%\ntest_1  | HTML version: file:///src/tmp/coverage/index.html\ndocker-compose_test_1 exited with code 0\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" This output states that the container started, 467 tests ran in 78 seconds with a successful (OK) status, and the code coverage of the API is 90%. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Test Code"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Test Code",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The test code for my API exists within a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/tree/v2.0.1/api/src/\ntests"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"tests",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory.  The file structure of the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"tests",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory matches the application source code directory.  For example, inside ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"tests",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-api/tree/v2.0.1/api/src/tests/test_src"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"test_src",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory, which matches the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/tree/v2.0.1/api/src"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"src",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory of the application.  Inside ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"test_src",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/tests/\ntest_src/testApp.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"testApp.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file, which is a test file corresponding to an ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/\nAJarombek/saints-xctf-api/blob/v2.0.1/api/src/app.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"app.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file in the source code.  As you can see, in the test code, directories and files are prefixed with ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"test",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Directories are in snake case while files are in camel case.  This isnâ€™t a required convention, but consistent naming makes it easy to associate test files with source code. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The contents of ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"testApp.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", which tests the entrypoint of the Flask application, is shown below. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"from flask import current_app, Response\nfrom tests.TestSuite import TestSuite\n\n\nclass TestApp(TestSuite):\n\n    def test_app_exists(self):\n        self.assertTrue(current_app is not None)\n\n    def test_non_existent_route(self) -> None:\n        \"\"\"\n        Test performing an HTTP GET request against an endpoint that doesn't exist. This query should invoke the\n        custom 404 error handler.\n        \"\"\"\n        response: Response = self.client.get('/path/doesnt/exist')\n        response_json: dict = response.get_json()\n        self.assertEqual(response.status_code, 404)\n        self.assertEqual(response_json.get('error_description'), 'Page Not Found')\n        self.assertGreater(len(response_json.get('exception')), 0)\n        self.assertEqual(response_json.get('contact'), 'andrew@jarombek.com')\n        self.assertEqual(response_json.get('api_index'), '/versions')\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" This test code contains two test functions: ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_app_exists()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_non_existent_route()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_app_exists()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" checks if ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"current_app",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", a proxy to the Flask application object, exists as expected",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"2",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_non_existent_route()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests that making an HTTP request to an invalid route in the API returns a specific JSON response with a 404 status code. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Each test file contains a single class with functions for individual tests.  These test classes, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"TestApp",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" in the example above, extend a base class called ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"TestSuite",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"TestSuite",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" performs setup and cleanup work for tests.  ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"TestSuite",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" extends a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"unittest.TestCase",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" class, which ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://docs.python.org/3.8/\nlibrary/unittest.html#test-cases"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"exposes methods",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" for performing setup and cleanup logic",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"3",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"TestSuite",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" overrides these methods, as shown below.  The full code is available in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/master/api/src/tests/TestSuite.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" TestSuite.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"import unittest\nimport os\nimport asyncio\nimport json\n\nimport boto3\nimport aiohttp\nfrom flask.testing import FlaskClient\n\nfrom config import config\nfrom app import create_app\nfrom database import db\n\n\nclass TestSuite(unittest.TestCase):\n    jwt = None\n    auth_url = None\n\n    @classmethod\n    def setUpClass(cls) -> None:\n        \"\"\"\n        Set up logic performed before each test class executes.\n        \"\"\"\n        flask_env = os.getenv('FLASK_ENV') or 'local'\n        auth_url = config[flask_env].AUTH_URL\n        TestSuite.auth_url = auth_url\n\n        secretsmanager = boto3.client('secretsmanager')\n        response = secretsmanager.get_secret_value(SecretId=f'saints-xctf-andy-password')\n        secret_string = response.get(\"SecretString\")\n        secret_dict = json.loads(secret_string)\n        client_secret = secret_dict.get(\"password\")\n\n        async def token():\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    url=f\"{auth_url}/token\",\n                    json={'clientId': 'andy', 'clientSecret': client_secret}\n                ) as response:\n                    response_body = await response.json()\n                    result = response_body.get('result')\n                    if result:\n                        TestSuite.jwt = result\n\n        asyncio.run(token())\n\n    def setUp(self) -> None:\n        \"\"\"\n        Set up logic performed before every test.\n        \"\"\"\n        if os.environ.get('ENV') == 'localtest':\n            env = 'localtest'\n        else:\n            env = 'test'\n\n        self.app = create_app(env)\n        self.app_context = self.app.app_context()\n        self.app_context.push()\n        self.client: FlaskClient = self.app.test_client()\n        self.jwt = TestSuite.jwt\n        self.auth_url = TestSuite.auth_url\n        self.jwts = {}\n\n    def tearDown(self) -> None:\n        \"\"\"\n        Tear down logic performed after every test.\n        \"\"\"\n        db.session.remove()\n        self.app_context.pop()\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The setup functions perform actions such as retrieving an authentication token (JWT) to use in tests and creating a test client for the API of type ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"FlaskClient",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  More expensive operations, such as making an external API call to receive a JWT, are performed in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"setUpClass()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" instead of ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"setUp()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  This way, long running tasks donâ€™t take place before each test function, only at the start of each class. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" I already showed some basic tests in the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/\ntests/test_src/testApp.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"testApp.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file, but now let's look at more complex examples. ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/master/api/src/tests/test_src/test_route/testGroupRoute.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" testGroupRoute.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is a file that tests all the API routes defined in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-api/blob/master/api/src/route/groupRoute.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"groupRoute.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" source code file.  Letâ€™s walk through a few tests, starting with ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_group_get_all_route_200()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"def test_group_get_all_route_200(self) -> None:\n    \"\"\"\n    Test performing an HTTP GET request on the '/v2/groups/' route.  This test proves that the endpoint returns\n    a list of groups.\n    \"\"\"\n    response: Response = self.client.get('/v2/groups/', headers={'Authorization': f'Bearer {self.jwt}'})\n    response_json: dict = response.get_json()\n    self.assertEqual(response.status_code, 200)\n    self.assertEqual(response_json.get('self'), '/v2/groups')\n    self.assertGreater(len(response_json.get('groups')), 1)\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/tests/test_src/test_route/testGroupRoute.py#L42-L51"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" This test",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" checks that API calls to the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/v2/groups/",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" endpoint returns a 200 status code and a specific JSON body.  It is very similar to the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_non_existent_route()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" test, except this API endpoint requires authentication, which is passed to the endpoint in the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"Authorization",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" header. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" A slightly more complex test is ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_group_by_id_put_route_400_not_an_admin()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"def test_group_by_id_put_route_400_not_an_admin(self) -> None:\n    \"\"\"\n    Test performing an HTTP PUT request on the '/v2/groups/<group_id>' route.  This test proves that\n    a user trying to update a group they are not an administrator of results in a 400 error.\n    \"\"\"\n    response: Response = self.client.get(\n        '/v2/groups/saintsxctf/wmenstf',\n        headers={'Authorization': f'Bearer {self.jwt}'}\n    )\n    response_json: dict = response.get_json()\n    self.assertEqual(response.status_code, 200)\n    self.assertIsNotNone(response_json.get('group'))\n    group_id = response_json.get('group').get('id')\n\n    response: Response = self.client.put(f'/v2/groups/{group_id}', headers={'Authorization': f'Bearer {self.jwt}'})\n    response_json: dict = response.get_json()\n    self.assertEqual(response.status_code, 400)\n    self.assertEqual(response_json.get('self'), f'/v2/groups/{group_id}')\n    self.assertFalse(response_json.get('updated'))\n    self.assertIsNone(response_json.get('group'))\n    self.assertEqual(\n        response_json.get('error'),\n        f'User andy is not authorized to update a group with id {group_id}.'\n    )\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/tests/test_src/test_route/\ntestGroupRoute.py#L269-L292"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"This test",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" asserts that if my user tries to update a group it is not a member of (the Womenâ€™s Track & Field group), the API returns a 400 error. Two API calls are needed to complete the test, which adds some complexity.  The first API call (a GET request) receives Womenâ€™s Track & Field group information, including a unique identifier for the group.  This unique identifier is stored in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"group_id",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and is used in the next API call, a PUT request to ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"/v2/groups/{group_id}",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" A successful variant of the test above is ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_group_by_id_put_route_200()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", which asserts that my user can update an Alumni group, which I am a member of. ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/tests/test_src/test_route/testGroupRoute.py#L326-L355"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" This test",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" also requires two API calls. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"def test_group_by_id_put_route_200(self) -> None:\n    \"\"\"\n    Test performing an HTTP PUT request on the '/v2/groups/<group_id>' route.  This test proves that if the updated\n    group object is valid and the user is an admin of the group, the group is updated and a 200 status code is\n    returned.\n    \"\"\"\n    response: Response = self.client.get(\n        '/v2/groups/saintsxctf/alumni',\n        headers={'Authorization': f'Bearer {self.jwt}'}\n    )\n    response_json: dict = response.get_json()\n    self.assertEqual(response.status_code, 200)\n    self.assertIsNotNone(response_json.get('group'))\n    group_id = response_json.get('group').get('id')\n\n    group_dict: dict = response_json.get('group')\n    group_dict['description'] = f\"Updated: {datetime.now()}\"\n    request_body = json.dumps(group_dict)\n\n    response: Response = self.client.put(\n        f'/v2/groups/{group_id}',\n        data=request_body,\n        content_type='application/json',\n        headers={'Authorization': f'Bearer {self.jwt}'}\n    )\n    response_json: dict = response.get_json()\n    self.assertEqual(response.status_code, 200)\n    self.assertEqual(response_json.get('self'), f'/v2/groups/{group_id}')\n    self.assertTrue(response_json.get('updated'))\n    self.assertIsNotNone(response_json.get('group'))\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" All the API endpoint tests in my application follow a similar pattern to the ones Iâ€™ve shown.  There are two other types of tests for my Flask application.  The first type is unit tests for utility functions in my API, such as those found in ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/tests/test_src/test_utils/testLogs.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" testLogs.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  This file tests conversions between distance units, such as converting miles to kilometers.  The second type is unit tests for ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/dec-24-2021-flask-python-api#database-models"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" SQLAlchemy Model classes",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  SQLAlchemy model class tests are located in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-api/tree/v2.0.1/api/src/tests/test_src/test_model"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"test_model",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" directory.  One example is ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/tests/test_src/test_model/testUser.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" testUser.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", which tests the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/model/User.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" User.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" model. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"from datetime import datetime\nfrom tests.TestSuite import TestSuite\nfrom model.User import User\n\n\nclass TestUser(TestSuite):\n    user1_dict = {\n        'username': \"andy\",\n        'first': 'Andy',\n        'last': 'Jarombek',\n        'salt': None,\n        'password': 'hashed_and_salted_password',\n        'profilepic': None,\n        'profilepic_name': None,\n        'description': \"Andy's Profile\",\n        'member_since': datetime.fromisoformat('2016-12-23'),\n        'class_year': 2017,\n        'location': 'Riverside, CT',\n        'favorite_event': '8K, 5000m',\n        'activation_code': 'ABC123',\n        'email': 'andrew@jarombek.com',\n        'subscribed': 1,\n        'last_signin': datetime.fromisoformat('2019-12-10'),\n        'week_start': 'monday',\n        'deleted': False\n    }\n\n    user2_dict = {\n        'username': \"andy2\",\n        'first': 'Andrew',\n        'last': 'Jarombek',\n        'salt': None,\n        'password': 'hashed_and_salted_password',\n        'profilepic': None,\n        'profilepic_name': None,\n        'description': None,\n        'member_since': datetime.fromisoformat('2019-12-10'),\n        'class_year': 2017,\n        'location': None,\n        'favorite_event': None,\n        'activation_code': 'DEF456',\n        'email': 'andrew@jarombek.com',\n        'subscribed': None,\n        'last_signin': datetime.now(),\n        'week_start': None,\n        'deleted': False\n    }\n\n    user1 = User(user1_dict)\n    user1copy = User(user1_dict)\n    user2 = User(user2_dict)\n\n    def test_user_str(self) -> None:\n        \"\"\"\n        Prove that the human readable string representation of a User object is as expected.\n        \"\"\"\n        log_str = 'User: [username: andy, first: Andy, last: Jarombek, salt: None, ' \\\n                  'password: hashed_and_salted_password, ' \\\n                  \"description: Andy's Profile, member_since: 2016-12-23 00:00:00, class_year: 2017, \" \\\n                  'location: Riverside, CT, favorite_event: 8K, 5000m, activation_code: ABC123, ' \\\n                  'email: andrew@jarombek.com, subscribed: 1, last_signin: 2019-12-10 00:00:00, week_start: monday, ' \\\n                  'deleted: False]'\n\n        self.maxDiff = None\n        self.assertEquals(str(self.user1), log_str)\n        self.assertEquals(self.user1.__str__(), log_str)\n\n    def test_user_repr(self) -> None:\n        \"\"\"\n        Prove that the machine readable string representation of a User object is as expected.\n        \"\"\"\n        self.assertEquals(repr(self.user1), \"<User 'andy'>\")\n        self.assertEquals(self.user1.__repr__(), \"<User 'andy'>\")\n\n    def test_user_eq(self) -> None:\n        \"\"\"\n        Prove that two User objects with the same property values test positive for value equality.\n        \"\"\"\n        self.assertTrue(self.user1 == self.user1copy)\n        self.assertTrue(self.user1.__eq__(self.user1copy))\n\n    def test_user_ne(self) -> None:\n        \"\"\"\n        Prove that two User objects with different property values test negative for value equality.\n        \"\"\"\n        self.assertTrue(self.user1 != self.user2)\n        self.assertTrue(self.user1.__ne__(self.user2))\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" There are a couple aspects of the model classes that I prioritize in these tests. ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_user_str()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests that the string representation of a model class (created by passing an instance of the class to ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"str()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":") is as expected. ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_user_repr()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" tests that the machine representation of a model class (created by passing an instance of the class to ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"repr()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":") is as expected. ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_user_eq()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"test_user_ne()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" test for value equality between instances of the model class. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" One piece of my API that is not directly under test is the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/\ndec-24-2021-flask-python-api#data-access-objects"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"Data Access Objects (DAOs)",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  My reasoning for this decision is that the DAOs are invoked by the API routes, so they are already indirectly tested by the API endpoint tests.  Testing them individually would be a duplication of these existing endpoint tests, just written in a different format. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Conclusions"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Conclusions",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Writing automated tests is critical for the reliability of any application, and hopefully this article helped illustrate that tests for Flask APIs are easy to set up and write.  All the code discussed in this article is available in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-api"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"saints-xctf-api",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository on GitHub. ",
                "children":null
            }
        ]
    }
];

preview = content.slice(1, 3);

postName = "jan-10-2022-flask-api-testing";
postDate = new Date('2022-01-10T12:00:00');
existingPost = db.posts.findOne({name: postName});

postViews = (existingPost) ? existingPost.views : 0;

db.posts.remove({name: postName});
db.posts_content.remove({name: postName});

db.posts.insertOne({
    name: postName,
    title: "Testing a Flask API",
    description: `As with any piece of software, this Flask API requires extensive testing to keep it functional and 
        maintainable.  In this article, I discuss the automated testing approach I implemented for the API.`,
    date: postDate,
    type: "Retrospective",
    views: postViews,
    tags: [
        {
            name: "Flask",
            picture: "https://asset.jarombek.com/logos/flask.png",
            color: "flask"
        },
        {
            name: "Python",
            picture: "https://asset.jarombek.com/logos/python.png",
            color: "python"
        },
        {
            name: "API"
        }
    ],
    preview,
    previewString: JSON.stringify(preview),
    sources: [
        {
            startName: "Miguel Grinberg, ",
            endName: ", 2nd ed (Sebastopol, CA: O'Reilly, 2018), 222",
            linkName: "Flask Web Development: Developing Web Applications with Python",
            link: "https://www.oreilly.com/library/view/flask-web-development/9781491991725/"
        },
        {
            startName: "\"The Application Context\", ",
            endName: "",
            linkName: "https://flask.palletsprojects.com/en/2.0.x/appcontext/",
            link: "https://flask.palletsprojects.com/en/2.0.x/appcontext/"
        },
        {
            startName: "\"Test cases\", ",
            endName: "",
            linkName: "https://docs.python.org/3.8/library/unittest.html#test-cases",
            link: "https://docs.python.org/3.8/library/unittest.html#test-cases"
        }
    ]
});

db.posts_content.insertOne({
    name: postName,
    date: postDate,
    content,
    contentString: JSON.stringify(content)
});
