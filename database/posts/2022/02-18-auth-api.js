/**
 * Script for the MongoDB Shell.
 * @author Andrew Jarombek
 * @since 2/18/2022
 */

connection = new Mongo();
db = connection.getDB("jarombekcom");

content = [
    {
        "el":"note",
        "attributes":{
            "type":"info"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" This is part of a series of articles on SaintsXCTF Version 2.0. The first article in the series provides an ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"overview of the application",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  You ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"DO NOT",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" need to read prior articles in the series to fully understand this article. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" My ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://saintsxctf.com/"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"SaintsXCTF",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" application has multiple APIs.  One of these APIs, ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"auth.saintsxctf.com",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", is hosted on AWS API Gateway and AWS Lambda.  Its main purpose is to provide an authentication mechanism for the application.  In this article, I discuss endpoints within this API and how they provide application authentication using JWTs. ",
                "children":null
            }
        ]
    },
    {
        "el":"subtitle",
        "attributes":{
            "title":"SaintsXCTF Version 2.0 Articles"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"SaintsXCTF Version 2.0 Articles",
                "children":null
            }
        ]
    },
    {
        "el":"ul",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Architectural Overview",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"AWS Infrastructure",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/oct-25-2021-saints-xctf-v2-k8s-infrastructure"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Kubernetes Infrastructure",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/nov-1-2021-saints-xctf-v2-react-web-app"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"React Web Application Overview",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/nov-15-2021-react-typescript"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application React and TypeScript",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/dec-3-2021-redux-react"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application Redux State Configuration",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/aug-11-2021-cypress-typescript"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application Cypress E2E Tests",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jun-30-2021-react-jss"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Web Application JSS Modular Design",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/dec-24-2021-flask-python-api"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Flask Python API",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/jan-10-2022-flask-api-testing"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Flask API Testing",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/feb-5-2022-function-api"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Function API Using API Gateway & Lambda",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"strong",
                        "attributes":null,
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Auth API Using API Gateway & Lambda",
                                "children":null
                            }
                        ]
                    }
                ]
            },
            {
                "el":"li",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"a",
                        "attributes":{
                            "href":"https://jarombek.com/blog/mar-27-2022-mysql-client-kubernetes"
                        },
                        "value":null,
                        "children":[
                            {
                                "el":"#text",
                                "attributes":null,
                                "value":"Database Client on Kubernetes",
                                "children":null
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"API Overview"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"API Overview",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The authentication API consists of two REST API endpoints backed by AWS Lambda functions and two standalone AWS Lambda functions. ",
                "children":null
            }
        ]
    },
    {
        "el":"inlineimage",
        "attributes":{
            "filename":"2-18-22-api-infrastructure.png",
            "paddingtop":"true",
            "paddingbottom":"true"
        },
        "value":null,
        "children":[

        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" AWS infrastructure for the API is created using Terraform.  This Terraform configuration exists in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-infrastructure/tree/master/saints-xctf-com-auth"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" saints-xctf-infrastructure",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository.  Infrastructure is ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/global-jenkins-jobs/\ntree/master/saints-xctf/infrastructure/create-saints-xctf-com-auth/Jenkinsfile.groovy"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"created",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/global-jenkins-jobs/blob/master/saints-xctf/infrastructure/\ndestroy-saints-xctf-com-auth/Jenkinsfile.groovy"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"destroyed",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" using Jenkins jobs.  In this article I focus on the functionality of the authentication API instead of the infrastructure, so I will not discuss infrastructure or CI/CD  processes in any more depth. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The idea behind this API is to have authentication logic separated from main application logic.  You can think of this API as a microservice for user authentication.  The authentication mechanism for the application is JWT tokens.  Users pass their username and password in exchange for a JWT token, which is used in subsequent API requests.  Behind the scenes, the application API checks whether a JWT token passed in an HTTP request is valid.  If the token is valid, the API request is processed and a response is returned.  If the token is invalid, an error message is returned.  JWTs expire after a certain amount of time, and the RSA key used to generate JWTs is rotated weekly for additional security. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The authentication API exposes two endpoints to users: ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/token",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/authenticate",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Both endpoints are backed by AWS Lambda functions.  The API has two additional AWS Lambda functions designed for internal usage: ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"SaintsXCTFAuthorizer",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"SaintsXCTFRotate",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Let's take a look at all these AWS Lambda functions in more detail. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Token Endpoint"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Token Endpoint",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/token",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" API endpoint is used to exchange user credentials for a JWT.  ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/token",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" accepts a JSON request body containing a username and a password.  The following CURL request shows how to properly use the endpoint. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Bash"
        },
        "value":"RequestBody='{\"clientId\":\"my_username\",\"clientSecret\":\"my_password\"}'\ncurl -X POST \\\n    -d \"${RequestBody}\" \\\n    -H \"Content-Type: application/json\" \\\n    https://auth.saintsxctf.com/token\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In the request body, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"my_username",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"my_password",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" are replaced with a user's username and password, respectively.  The response body will look something like the following, with ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"j.w.t",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" replaced with a valid JWT. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JSON"
        },
        "value":"{\n    \"result\": \"j.w.t\"\n}\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" As previously mentioned, each endpoint is backed by an AWS Lambda function.  The function for the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/token",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" endpoint is shown below, and exists in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth/\nblob/master/token/function.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"function.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file within my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" saints-xctf-auth",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"import os\nimport boto3\nimport json\nimport re\nfrom datetime import datetime\nfrom typing import Any\n\nimport jwt\nimport bcrypt\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom boto3_type_annotations.secretsmanager import Client as SecretsManagerClient\nfrom boto3_type_annotations.rds import Client as RDSClient\n\nfrom User import User\n\n\ndef lambda_handler(event, context):\n    client_id = event['clientId']\n    client_secret = event['clientSecret']\n    env = os.environ['ENV']\n    print(f\"Client: {client_id}, Environment: {env}\")\n\n    secretsmanager: SecretsManagerClient = boto3.client('secretsmanager', region_name='us-east-1')\n    rds: RDSClient = boto3.client('rds', region_name='us-east-1')\n\n    private_key = get_jwt_private_key(secretsmanager, env)\n    db_secret = get_rds_credentials(secretsmanager, env)\n    session = create_database_session(rds, db_secret, env)\n    print(\"Database Session Initialized and Secrets Retrieved\")\n\n    email_pattern = re.compile('^(([a-zA-Z0-9_.-])+@([a-zA-Z0-9_.-])+\\\\.([a-zA-Z])+([a-zA-Z])+)?$')\n\n    if email_pattern.match(client_id):\n        print(\"Retrieving User by Email\")\n        user = session.query(User).filter_by(email=client_id).first()\n    else:\n        print(\"Retrieving User by Username\")\n        user = session.query(User).filter_by(username=client_id).first()\n\n    if user is None:\n        print(f\"No user exists with username/email: {client_id}\")\n        return None\n    else:\n        print(\"A user exists with given client ID.\")\n        if bcrypt.checkpw(client_secret.encode('utf-8'), user.password.encode('utf-8')):\n            print(\"User credentials valid.\")\n            iat = int(datetime.utcnow().timestamp())\n            exp = iat + 2419200\n\n            return jwt.encode(\n                payload={\n                    'iat': iat,\n                    'exp': exp,\n                    'iss': 'auth.saintsxctf.com',\n                    'sub': user.username,\n                    'email': user.email,\n                    'name': f'{user.first} {user.last}'\n                },\n                key=private_key,\n                algorithm='RS256'\n            )\n        else:\n            print(f\"Invalid password for user with username/email: {client_id}\")\n            return None\n\n\ndef get_jwt_private_key(secretsmanager: SecretsManagerClient, env: str) -> str:\n    \"\"\"\n    Get the RSA encrypted private key used to create JWT tokens.\n    :param secretsmanager: boto3 client for working with SecretsManager.\n    :param env: Environment of the SaintsXCTF authentication private key.\n    :return: A string representing the RSA encrypted private key.\n    \"\"\"\n    print(\"Getting JWT Private Key\")\n    secret = secretsmanager.get_secret_value(SecretId=f\"saints-xctf-auth-{env}\")\n\n    secret_string = secret.get('SecretString')\n    secret_dict: dict = json.loads(secret_string)\n    return secret_dict[\"PrivateKey\"]\n\n\ndef get_rds_credentials(secretsmanager: SecretsManagerClient, env: str) -> dict:\n    \"\"\"\n    Get the RDS username and password.\n    :param secretsmanager: boto3 client for working with SecretsManager.\n    :param env: Environment of the SaintsXCTF database.\n    :return: A dictionary containing username and password keys.\n    \"\"\"\n    print(\"Getting RDS Credentials\")\n    response = secretsmanager.get_secret_value(SecretId=f'saints-xctf-rds-{env}-secret')\n    secret_string = response.get(\"SecretString\")\n    return json.loads(secret_string)\n\n\ndef create_database_session(rds: RDSClient, db_secret: dict, env: str) -> Any:\n    \"\"\"\n    Create a database session with RDS in a given environment.\n    :param rds: boto3 client for working with RDS.\n    :param db_secret: Dictionary containing the username and password for the SaintsXCTF RDS/MySQL database.\n    :param env: Environment of the SaintsXCTF database.\n    :return: A session with the database.\n    \"\"\"\n    print(\"Creating Database Session\")\n    rds_instances = rds.describe_db_instances(DBInstanceIdentifier=f'saints-xctf-mysql-database-{env}')\n    instance = rds_instances.get('DBInstances')[0]\n    hostname = instance.get('Endpoint').get('Address')\n\n    username = db_secret.get(\"username\")\n    password = db_secret.get(\"password\")\n    database = 'saintsxctf'\n\n    db_url = f'mysql+pymysql://{username}:{password}@{hostname}/{database}'\n\n    engine = create_engine(db_url)\n\n    Session = sessionmaker()\n    Session.configure(bind=engine)\n\n    return Session()\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"lambda_handler()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is the entrypoint to the AWS Lambda function.  Within ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"lambda_handler()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", the first two lines extract the JSON request body fields into ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"client_id",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" and ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"client_secret",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" variables.  The function works in both development and production environments, as determined by an ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"ENV",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" environment variable.  The environment is retrieved with the line ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"env = os.environ['ENV']",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  The environment is important because different databases and RSA keys are used in different environments. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Next comes a series of helper function invocations.  First, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"get_jwt_private_key(secretsmanager, env)",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" retrieves an RSA private key from AWS Secrets Manager.  This private key is used to create JWTs.  Second, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"get_rds_credentials(secretsmanager, env)",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" retrieves MySQL database credentials.  The database is queried to determine if the username and password sent to the API are valid.  The third and final helper function, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"create_database_session(rds, db_secret, env)",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":", uses the database credentials to start a session with the application's MySQL database. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Optionally, the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/token",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" endpoint takes an email instead of a username.  This option is expressed by an ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"if",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" statement and a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"email_pattern.match(client_id)",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" condition.  If an email is used, the user in the database is retrieved with ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"session.query(User).filter_by(email=client_id).first()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Otherwise, the user is retrieved with ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"session.query(User).filter_by(username=client_id).first()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  In both cases, a SQLAlchemy model class ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"User",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is utilized to query the database.  I wrote about SQLAlchemy and model classes in ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/\ndec-24-2021-flask-python-api"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"an article on my SaintsXCTF API",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  The ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"User",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" model class exists in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth/blob/master/token/User.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" User.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file and is shown below. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"from sqlalchemy import Column, VARCHAR\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    username = Column(VARCHAR(20), primary_key=True)\n    first = Column(VARCHAR(30), nullable=False, index=True)\n    last = Column(VARCHAR(30), nullable=False, index=True)\n    password = Column(VARCHAR(255), nullable=False)\n    email = Column(VARCHAR(50), index=True)\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" If the database query for a user with a certain username or email returns no records, the AWS Lambda function returns ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"None",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Otherwise, it checks if the user's password matches the one in the API request body (",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"client_secret",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":").  Passwords are encrypted in my database using Bcrypt, so a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"bcrypt.checkpw()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" function is used to check for password equality. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" If the password submitted in the API request is invalid, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"None",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is returned. Otherwise, a JWT is created and returned using the ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"jwt.encode()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" function. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Authenticate Endpoint"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Authenticate Endpoint",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/authenticate",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" API endpoint is used to validate a JWT and accepts a JSON request body containing a JWT.  The following CURL request shows how to properly use the endpoint. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Bash"
        },
        "value":"RequestBody='{\"jwt\":\"my_jwt\"}'\ncurl -X POST \\\n    -d \"${RequestBody}\" \\\n    -H \"Content-Type: application/json\" \\\n    https://auth.saintsxctf.com/authenticate\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" In the request body, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"my_jwt",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is replaced with the user's JWT.  The response body looks like the following JSON.  In this example, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"true",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is returned due to a valid JWT. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"JSON"
        },
        "value":"{\n    \"result\": true\n}\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The function for the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/authenticate",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" endpoint is shown below, and exists in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth/blob/master/authenticate/function.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"function.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file within my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"saints-xctf-auth",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"import os\nimport traceback\nimport boto3\nimport json\n\nimport jwt\nfrom boto3_type_annotations.secretsmanager import Client\n\n\ndef lambda_handler(event, context):\n    token = event['token']\n    env = os.environ['ENV']\n    print(f\"Token: {token}, Environment: {env}\")\n\n    secretsmanager: Client = boto3.client('secretsmanager')\n    secret = secretsmanager.get_secret_value(SecretId=f\"saints-xctf-auth-{env}\")\n\n    secret_string = secret['SecretString']\n    secret_dict: dict = json.loads(secret_string)\n\n    try:\n        jwt.decode(\n            jwt=token,\n            key=secret_dict[\"PublicKey\"],\n            verify=True,\n            algorithms='RS256',\n            options={'require': ['exp', 'iat', 'iss']}\n        )\n        return True\n    except jwt.ExpiredSignatureError:\n        print(\"This token has expired.\")\n        return False\n    except Exception as e:\n        print(\"The token is invalid.\")\n        traceback.print_exception(type(e), e, e.__traceback__)\n        return False\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The AWS Lambda function for ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/authenticate",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is a bit simpler than the one for ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/token",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". Again, ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"lambda_handler()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is the entrypoint to the AWS Lambda function.  The first line in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"lambda_handler()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" gets the JWT token and places it in a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"token",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" variable.  Again, AWS Secrets Manager is used to get the RSA keys used to validate the JWT.  The RSA keys are stored in a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"secret_dict",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" variable. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The remainder of the code attempts to decode the JWT token using a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"jwt.decode()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" function.  If the JWT token is deemed valid, the function returns ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"True",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  Otherwise, there are two possible scenarios, both of which cause the function to return ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"False",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  The first scenario is when the token expired, resulting in a ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"jwt.ExpiredSignatureError",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" exception.  The second is when the token is invalid,  which can result in any number of exceptions. ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Rotate Lambda Function"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Rotate Lambda Function",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The \"Rotate\" AWS Lambda function is used internally by the authentication API.  It's purpose is to rotate the RSA public  and private keys, which are used to create and decode JWTs.  In my application, key rotation occurs every seven days.  RSA key rotation is done  to defend the application from malicious users attempting to gain access to the keys.  If malicious users gain access to the keys, they can create their own JWTs.  These JWTs would be valid to my application, even though my application did not create them.  By rotating the RSA keys, the damage is limited because the malicious user will only have access to valid RSA keys until the next rotation.  After a key rotation occurs, existing RSA keys are no longer able to create or validate JWT tokens.  The malicious user will no longer be able to cause harm to the application. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The \"Rotate\" AWS Lambda function is written in Python and exists in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-auth/blob/master/rotate/function.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"function.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file within my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/\nsaints-xctf-auth"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"saints-xctf-auth",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository.  It is based off a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/aws-samples/\naws-secrets-manager-ssh-key-rotation/tree/master/lambda"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"sample AWS Lambda function",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" for rotating secrets",
                "children":null
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"1",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  More information on rotating secrets using AWS Secrets Manager and AWS Lambda can be found in the ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"AWS documentation",
                        "children":null
                    }
                ]
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"2",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Authorizer Lambda Function"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Authorizer Lambda Function",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The \"Authorizer\" AWS Lambda function is used as an ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://docs.aws.amazon.com/apigateway/latest/\ndeveloperguide/apigateway-use-lambda-authorizer.html"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"API Gateway authorizer",
                        "children":null
                    }
                ]
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"3",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":".  API Gateway authorizers enable custom authentication for API Gateway endpoints, such as the ones in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://jarombek.com/blog/\nfeb-5-2022-function-api"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"fn.saintsxctf.com",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" API. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" This authorizer checks if a JWT token passed in an API request is valid for my application.  If the token is valid, requests are forwarded to API endpoints in AWS API Gateway.  If the token is invalid, requests are denied.  The function is very similar to the one behind my ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/authenticate",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" endpoint, except this time it is for internal use by API Gateway, not publicly accessible over HTTP. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" The \"Authorizer\" function is shown below, and exists in a ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth/blob/master/authenticate/function.py"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"function.py",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" file within my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"saints-xctf-auth",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository. ",
                "children":null
            }
        ]
    },
    {
        "el":"codesnippet",
        "attributes":{
            "language":"Python"
        },
        "value":"import os\nimport json\nimport traceback\n\nimport jwt\nfrom boto3_type_annotations.secretsmanager import Client\n\n\ndef lambda_handler(event, context):\n    token = event['authorizationToken']\n    method_arn = event['methodArn']\n    env = os.environ['ENV']\n    print(f\"Token: {token}, Environment: {env}\")\n\n    secretsmanager: Client = boto3.client('secretsmanager')\n    secret = secretsmanager.get_secret_value(SecretId=f\"saints-xctf-auth-{env}\")\n\n    secret_string = secret['SecretString']\n    secret_dict: dict = json.loads(secret_string)\n\n    try:\n        jwt.decode(\n            jwt=token,\n            key=secret_dict[\"PublicKey\"],\n            verify=True,\n            algorithms='RS256',\n            options={'require': ['exp', 'iat', 'iss']}\n        )\n        return allow_policy(method_arn)\n    except jwt.ExpiredSignatureError:\n        # The date of the 'exp' claim is in the past, meaning the token is expired\n        print(\"This token has expired.\")\n        return deny_policy()\n    except Exception as e:\n        print(\"Unknown error occurred.\")\n        traceback.print_exception(type(e), e, e.__traceback__)\n        return deny_policy()\n\n\ndef allow_policy(method_arn: str) -> dict:\n    return {\n        \"principalId\": \"apigateway.amazonaws.com\",\n        \"policyDocument\": {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Action\": \"execute-api:Invoke\",\n                    \"Effect\": \"Allow\",\n                    \"Resource\": method_arn\n                }\n            ]\n        }\n    }\n\n\ndef deny_policy() -> dict:\n    return {\n        \"principalId\": \"*\",\n        \"policyDocument\": {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Action\": \"*\",\n                    \"Effect\": \"Deny\",\n                    \"Resource\": \"*\"\n                }\n            ]\n        }\n    }\n",
        "children":null
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Similar to the ",
                "children":null
            },
            {
                "el":"strong",
                "attributes":null,
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"/authenticate",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" endpoint, the result of ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"jwt.decode()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" determines the output of the AWS Lambda function.  However, instead of returning a boolean  to determine whether a JWT is valid, the authorizer returns a Python dictionary.  This dictionary represents a JSON IAM policy that is used to invoke API Gateway endpoints.  If the JWT is valid, the IAM policy defined in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"allow_policy()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is returned.  If the JWT is invalid, the IAM policy defined in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"deny_policy()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" is returned.  The policy in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"allow_policy()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" allows access to API endpoints while the policy in ",
                "children":null
            },
            {
                "el":"code",
                "attributes":{
                    "className":"jarombek-inline-code"
                },
                "value":"deny_policy()",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" denies access. ",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" These four functions fulfill all the authentication needs of my application!  Potential enhancements to this approach include making the JWT tokens ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://developer.okta.com/docs/concepts/oauth-openid/\n#authentication-api-vs-oauth-2-0-vs-openid-connect"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":"OAuth2 or OpenID Connect protocol compliant",
                        "children":null
                    }
                ]
            },
            {
                "el":"sup",
                "attributes":null,
                "value":"3",
                "children":null
            },
            {
                "el":"#text",
                "attributes":null,
                "value":". ",
                "children":null
            }
        ]
    },
    {
        "el":"sectiontitle",
        "attributes":{
            "title":"Conclusions"
        },
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":"Conclusions",
                "children":null
            }
        ]
    },
    {
        "el":"p",
        "attributes":null,
        "value":null,
        "children":[
            {
                "el":"#text",
                "attributes":null,
                "value":" Using AWS API Gateway and AWS Lambda is an effective way to create a basic authentication API for an application.  The main drawback of this approach is AWS Lambda cold starts and the expenses involved with mitigating them.  Otherwise, its a great way to separate authentication logic into its own serverless microservice. All the code discussed in this article is available in my ",
                "children":null
            },
            {
                "el":"a",
                "attributes":{
                    "href":"https://github.com/AJarombek/saints-xctf-auth"
                },
                "value":null,
                "children":[
                    {
                        "el":"#text",
                        "attributes":null,
                        "value":" saints-xctf-auth",
                        "children":null
                    }
                ]
            },
            {
                "el":"#text",
                "attributes":null,
                "value":" repository. ",
                "children":null
            }
        ]
    }
];

preview = content.slice(1, 3);

postName = "feb-18-2022-auth-api";
postDate = new Date('2022-02-18T12:00:00');
existingPost = db.posts.findOne({name: postName});

postViews = (existingPost) ? existingPost.views : 0;

db.posts.remove({name: postName});
db.posts_content.remove({name: postName});

db.posts.insertOne({
    name: postName,
    title: "Building an API for Authentication with AWS Lambda and API Gateway",
    description: `The idea behind this API is to have authentication logic separated from the main application logic.  
        You can think of this API as a microservice for user authentication.  The authentication approach for my 
        application is to use JWT tokens.`,
    date: postDate,
    type: "Retrospective",
    views: postViews,
    tags: [
        {
            name: "AWS Lambda",
            picture: "https://asset.jarombek.com/logos/awslambda.png",
            color: "awslambda"
        },
        {
            name: "API Gateway",
            picture: "https://asset.jarombek.com/logos/apigateway.svg",
            color: "apigateway"
        },
        {
            name: "AWS",
            picture: "https://asset.jarombek.com/logos/aws.png",
            color: "aws"
        },
        {
            name: "Terraform",
            picture: "https://asset.jarombek.com/logos/terraform.png",
            color: "terraform"
        },
        {
            name: "Python",
            picture: "https://asset.jarombek.com/logos/python.png",
            color: "python"
        }
    ],
    preview,
    previewString: JSON.stringify(preview),
    sources: [
        {
            startName: "\"aws-secrets-manager-ssh-key-rotation\", ",
            endName: "",
            linkName: "https://github.com/aws-samples/aws-secrets-manager-ssh-key-rotation/tree/master/lambda",
            link: "https://github.com/aws-samples/aws-secrets-manager-ssh-key-rotation/tree/master/lambda"
        },
        {
            startName: "\"How rotation works\", ",
            endName: "",
            linkName: "https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html",
            link: "https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html"
        },
        {
            startName: "\"OAuth 2.0 and OpenID Connect Overview: Authentication API vs OAuth 2.0 vs OpenID Connect\", ",
            endName: "",
            linkName: "https://developer.okta.com/docs/concepts/oauth-openid/#authentication-api-vs-oauth-2-0-vs-openid-connect",
            link: "https://developer.okta.com/docs/concepts/oauth-openid/#authentication-api-vs-oauth-2-0-vs-openid-connect"
        }
    ]
});

db.posts_content.insertOne({
    name: postName,
    date: postDate,
    content,
    contentString: JSON.stringify(content)
});
